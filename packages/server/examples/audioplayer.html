<m-group sx="0.4" sy="0.4" ry="90">
  <m-audio
    id="my-audio-tag"
    z="-4"
    y="0"
    width="25"
    rx="0"
    ry="0"
    start-time="0"
    loop="true"
    src="https://s3.eu-west-2.amazonaws.com/s3uk.mgz.me/vod/out_of_time.mp3"
  >
    <m-shader
      audio="my-audio-tag"
      z="4"
      y="-0.249"
      x="0"
      rx="-90"
      width="25"
      height="10"
      vert="
void main() {
  vUv = uv;
  gl_PointSize = 1.;
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
      "
      frag="
precision highp float;
uniform sampler2D prgm1Texture;

const float PI = acos(-1.0);
const float TAU = PI * 2.0;

const int NUM_SAMPLES = 32;
const float Density = 0.5;
const float Exposure = 0.3;

float rand(vec2 uv, float t) {
  float seed = dot(uv, vec2(12.9898, 78.233));
  return fract(sin(seed) * 43758.5453123 + t);
}

float gaussian(float z, float u, float o) {
  return (
    (1.0 / (o * sqrt(TAU))) *
    (exp(-(((z - u) * (z - u)) / (2.0 * (o * o)))))
  );
}

vec3 gaussgrain(float t) {
  vec2 ps = vec2(1.01) / resolution.xy;
  vec2 uv = gl_FragCoord.xy * ps;
  float noise = rand(uv, t);
  noise = gaussian(noise, 0.0, 0.5);
  return vec3(noise);
}

void main(void) {
  vec2 uv = vUv;
  vec2 dist = uv - 0.5;
  dist.x += sin(0.125 * dist.y + time) * 0.025;
  dist.y += cos(0.125 * dist.x + time) * 0.025;
  float Density = 0.75 + 0.2 * sin(2.0 * radians(360.0));
  dist *= 1.0 / float(NUM_SAMPLES) * Density;
  float frameScale = 29.97;
  float frameTime = floor(time * frameScale) / frameScale;
  vec3 g = gaussgrain(frameTime) * 0.04;
  vec3 color = texture2D(prgm1Texture, uv).rgb;
  vec3 cc = color;
  float illuminationDecay = 1.0;
  for (int i = 0; i < NUM_SAMPLES; i++)   {
    uv -= dist;
    vec3 sample_ = texture2D(prgm1Texture, uv + dist * rand(uv, time)).rgb + g;
    sample_ *= illuminationDecay * 1.0 + fft * 2.0;
    color += sample_;
    float Decay = 0.6 + fft * 0.8;
    illuminationDecay *= Decay;
  }
  gl_FragColor = vec4(mix(color * color * Exposure, cc, 0.5), 1.0);
}
      "
      >
      <!-- prgm1Texture -->
      <m-shader
      frag="
precision highp float;
    
const float PI = acos(-1.0);
const float TAU = PI * 2.0;
const float SQRT3 = sqrt(3.0);
const float TAN30 = SQRT3 / 3.0;
const float HALFPI = PI / 2.0;
const float TTP = 1.0 / 3.0;
const float SSP = 1.0 / 1.5;
const float STH = 1.0 / 6.0;
const float T1R = 120.0;
const float T2R = T1R * 3.0;

float rand(vec2 uv) {
  float d = dot(uv.xy, vec2(12.9898, 78.233));
  return fract(sin(d) * 43758.545312);
}

float dfNoise21(vec2 uv) {
  vec3 p = fract(vec3(uv.xyx) * 0.1031);
  p += dot(p, p.yzx + 33.33);
  return fract((p.x + p.y) * p.z);
}

float fbm(vec2 uv) {
  float z = 2.0;
  float c = 0.0;
  vec2 u = uv;
  for(float e = 1.0; e < 6.0; e++) {
    c += abs(
      ((mix(dfNoise21(u), rand(u), 0.5) - 0.5) * 2.0)
    ) / z;
    z=z*2.,uv=uv*2.;
  }
  return c;
}

mat2 rotate(float x) {
  float c = cos(x);
  float s = sin(x);
  return mat2( c, -s, s, c);
}

float dualFBM(vec2 a) {
  vec2 c=a*.7;
  vec2 b=vec2(fbm(c*1.65),fbm(c*1.7));b=(b-.5)*.2,a+=b;
  return fbm(a*rotate(.2));
}

vec2 curve(vec2 uv) {
  uv.x *= 1.0 + pow(abs(uv.y / 5.0), 2.0);
  uv.y *= 1.0 + pow(abs(uv.x / 4.0), 2.0);
  uv = uv * 0.92 + 0.04;
  return uv;
}

float ssin(float t) {
  return (2.0 / PI) * atan(sin(TAU * t * 0.5) / 0.1) * 2.0;
}

float nzClamp(float x) {
  return clamp(x, 0.1, 1.0);
}

vec3 nzClamp(vec3 x) {
  return clamp(x, 0.1, 1.0);
}

vec3 hsv2rgb(vec3 c) {
  c.yz = clamp(c.yz, 0.0, 1.0);
  vec3 t = vec3(0.0, SSP, TTP);
  vec3 ct = cos(PI * (c.x + t)) - 1.0;
  return c.z * (1.0 + 0.5 * c.y * ct);
}

vec3 hueRotate(vec3 c, float a) {
  vec2 zhPI = vec2(0.0, HALFPI);
  vec2 s = sin(vec2(radians(a)) + zhPI);
  vec3 rot = vec3(TAN30, s);
  vec3 cc = cross(rot.xxx, c);
  float dc = dot(rot.xxx, c);
  return mix(rot.xxx * dc, c, rot.z) + cc * rot.y;
}

void main(void) {
  vec2 uv = vUv * 2.0 - 1.0;
  float ar = resolution.x / resolution.y;
  uv.x *= ar;
  vec2 c = curve(vUv);
  float t1 = mod(time * 6.0, T1R);
  float t2 = mod(time * 0.3, T2R);
  float ot1 = nzClamp(ssin(t2 * STH) + 1.0);
  float ot2 = nzClamp(ssin(t2 * TTP) + 1.0);
  float T = 2.0 - mix(mix(1.0, 0.125, ot2), mix(0.5, 0.25, ot2), ot1) * 0.5;
  uv *= 1.0 - 0.2 * cos(uv.yx) * sin(PI / 10.0);
  uv *= 9.0 * T;
  float f = fft * 3.0;
  f *= f;
  float fbmA = dualFBM(floor(uv)) + f;
  float fbmB = dualFBM(floor(uv * 0.5)) + f;
  float fbmC = dualFBM(floor(uv * 0.25)) + f;
  float fbmD = dualFBM(floor(uv * 0.125))+f;
  float rnd = nzClamp(mix(mix(fbmA, fbmD, ot2), mix(fbmB, fbmC, ot2), ot1));
  vec2 black = clamp(smoothstep(2.5, 0.0, cos(uv * TAU)), 0.1, 0.9);
  vec3 colA = clamp(
    hsv2rgb(vec3(8.0 * cos(rnd), 1.5 / rnd, 5.0 * pow(abs(rnd), rnd))), 0.5, 0.9
  );
  vec3 colB = clamp(
    hsv2rgb(vec3(7.0 * cos(fbmA), 1.5 / fbmA, 5.0 * pow(abs(fbmA), abs(fbmA)))), 0.2, 0.9
  );
  float p = nzClamp(black.x * black.y * smoothstep(0.9, 0.2, length(fract(uv) - 0.5)));
  float u = nzClamp(0.5 + 0.5 * cos(rnd * t1 + TAU));
  colA *= p; colB *= p; colA *= u; colB *= u;
  vec3 cA = colA;
  vec3 v = sqrt(colA * colA * colB);
  vec3 w = sqrt(colA * colA / colB);
  cA = clamp(cA * 2.0, 0.1, 0.9);
  vec3 cB = nzClamp(sqrt(mix(mix(cA, colB, ot2),mix(v, w, ot2), ot1) / w * v));
  cB *= (0.99 + 0.01 * sin(110.0 * t1)) * 5.0;
  float vig = 16.0 * c.x * c.y * (1.0 - c.x) * (1.0 - c.y);
  cB *= vec3(pow(abs(vig), 0.5));
  if (c.x < 0.0 || c.x > 1.0) { cB *= 0.0; }
  if (c.y < 0.0 || c.y > 1.0) { cB *= 0.0; }
  vec4 color = vec4(cB * 2.0, colA.x * colB.x * cA.x + p * cA.x + p * 0.95);
  color.xyz *= cA.x * 0.25;
  color.r *= 0.3; color.g *= 0.2;
  gl_FragColor=clamp(color * fbmA * 2.0, 0.0, 1.0);
}
      "
      >
      </m-shader>
    </m-shader>

    <m-label
      onclick="pause(event.currentTarget.parentNode)"
      content="pause"
      x="-10"
      y="0.15"
      z="8.4"
      rx="-55"
      font-size="100"
      width="5"
      alignment="center"
      height="1.5"
      color="#ffffff"
    ></m-label>
    <m-label
      onclick="unpause(event.currentTarget.parentNode)"
      content="unpause"
      x="-5"
      y="0.15"
      z="8.4"
      rx="-55"
      font-size="100"
      width="5"
      alignment="center"
      height="1.5"
      color="#dddddd"
    ></m-label>
    <m-label
      onclick="toggleEnabled(event.currentTarget.parentNode)"
      content="enable"
      x="0"
      y="0.15"
      z="8.4"
      rx="-55"
      font-size="100"
      width="5"
      alignment="center"
      height="1.5"
      color="#ffffff"
    ></m-label>
    <m-label
      onclick="resume(event.currentTarget.parentNode)"
      content="resume"
      x="5"
      y="0.15"
      z="8.4"
      rx="-55"
      font-size="100"
      width="5"
      alignment="center"
      height="1.5"
      color="#dddddd"
    ></m-label>
    <m-label
      onclick="restart(event.currentTarget.parentNode)"
      content="restart"
      x="10"
      y="0.15"
      z="8.4"
      rx="-55"
      font-size="100"
      width="5"
      alignment="center"
      height="1.5"
      color="#ffffff"
    ></m-label>
    <m-label
      class="attributes-label"
      content="attrs:"
      x="0"
      y="0.55"
      z="-1"
      rx="0"
      padding="10"
      font-size="50"
      width="25"
      height="1.5"
      alignment="center"
      height="2"
      color="#cccccc"
      font-color="black"
    ></m-label>
  </m-audio>
</m-group>
<script>
  function updateAttributesLabel(audioTag) {
    const attributes = [];
    for (const attr of audioTag.getAttributeNames()) {
      const val = audioTag.getAttribute(attr);
      attributes.push(`${attr}="${val}"`);
    }
    const attributesLabel = audioTag.querySelector(".attributes-label");
    if (attributesLabel) {
      attributesLabel.setAttribute("content", `<m-audio ${attributes.join(" ")}></m-audio>`);
    }
  }

  function restart(audioTag) {
    audioTag.setAttribute("pause-time", document.timeline.currentTime);
    audioTag.setAttribute("start-time", document.timeline.currentTime);
    audioTag.removeAttribute("pause-time");
    updateAttributesLabel(audioTag);
  }

  function toggleEnabled(audioTag) {
    const enabled = audioTag.getAttribute("enabled") !== "false";
    audioTag.setAttribute("enabled", (!enabled).toString());
    updateAttributesLabel(audioTag);
  }

  function pause(audioTag) {
    audioTag.setAttribute("pause-time", document.timeline.currentTime);
    updateAttributesLabel(audioTag);
  }

  function unpause(audioTag) {
    audioTag.removeAttribute("pause-time");
    updateAttributesLabel(audioTag);
  }

  function resume(audioTag) {
    if (!audioTag.hasAttribute("pause-time")) return;
    const startTime = parseFloat(audioTag.getAttribute("start-time")) || 0;
    const pauseTime = parseFloat(audioTag.getAttribute("pause-time")) || 0;
    const playedDuration = pauseTime - startTime;
    const newStartTime = document.timeline.currentTime - playedDuration;
    audioTag.removeAttribute("pause-time");
    audioTag.setAttribute("start-time", newStartTime);
    updateAttributesLabel(audioTag);
  }

  for (const audio of document.querySelectorAll("m-audio")) {
    updateAttributesLabel(audio);
  }
</script>
